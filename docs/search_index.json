[["index.html", "Propuesta de serie de tiempo: Predicción de demanda eléctrica a corto plazo Maestría en Ciencia de Datos 1 Presentación del Bookdown", " Propuesta de serie de tiempo: Predicción de demanda eléctrica a corto plazo Maestría en Ciencia de Datos Fredy A. Ordoñez · Oscar F. Velásquez · José L. Sánchez 18 de octubre de 2025 1 Presentación del Bookdown Este Bookdown recopila las actividades desarrolladas a lo largo del curso de Series de Tiempo. Cada capítulo corresponde a una entrega o avance del proyecto, permitiendo evidenciar el progreso del análisis, los modelos aplicados y las conclusiones del trabajo final. ## NULL "],["propuesta.html", "2 Propuesta de serie de tiempo: Predicción de demanda eléctrica a corto plazo 2.1 ¿Qué voy a pronosticar? 2.2 ¿Por qué es importante? 2.3 Fuente de datos y permisos 2.4 Impacto esperado 2.5 Referencias", " 2 Propuesta de serie de tiempo: Predicción de demanda eléctrica a corto plazo 2.1 ¿Qué voy a pronosticar? La demanda eléctrica de corto plazo (1 hora adelante) en una subestación de distribución, usando la serie de potencia activa (kW) con resolución horaria. 2.2 ¿Por qué es importante? Operación eficiente: anticipar picos para evitar sobrecargas y maniobras reactivas. Calidad del servicio (SAIDI/SAIFI): programar mantenimientos y gestionar eventos reduciendo frecuencia y duración de interrupciones.SAIFI (System Average Interruption Frequency Index) indica la frecuencia promedio de las interrupciones que un cliente experimenta en un período determinado (por ejemplo, cuántas veces se va la luz al año), y el SAIDI (System Average Interruption Duration Index) mide la duración promedio acumulada de esas interrupciones para un cliente en ese mismo período (cuánto tiempo en total está sin servicio). Valor agregado: entregar una plantilla reproducible (scripts, métricas y gráficos) que soporte decisiones operativas. 2.3 Fuente de datos y permisos Fuente: datos SCADA históricos del operador de red de una subestación específica resolución horaria. Permisos: uso académico con anonimización de subestación y operador; no se publican datos crudos, solo resultados agregados y visualizaciones. Alcance: una subestación; análisis offline (sin integración en tiempo real). 2.4 Impacto esperado Técnico: reducción de error frente a métodos manuales; soporte a decisiones en turnos. Económico: mejor dimensionamiento de respaldo y diferimiento de inversiones. Académico: caso replicable en otras subestaciones con datos equivalentes. 2.5 Referencias Hyndman, R. &amp; Athanasopoulos (2018). Forecasting: Principles and Practice (3ª). Box, G. et al. (2015). Time Series Analysis: Forecasting and Control (5ª). Zhang, H. et al. (2019). “Short-term Load Forecasting Using LSTM Networks”, IEEE TSG. Herramienta TIC: Bookdown + GitHub Pages Sitio: https://joseluissanchezceballos.github.io/TimeSeries/propuesta.html Repo: https://github.com/joseluissanchezceballos/TimeSeries "],["Estructura.html", "3 Análisis exploratorio de una serie de tiempo (MA, rezagos y estacionalidad)", " 3 Análisis exploratorio de una serie de tiempo (MA, rezagos y estacionalidad) Carga de librerías y datos library(readr) ## Warning: package &#39;readr&#39; was built under R version 4.4.3 library(dplyr) ## ## Adjuntando el paquete: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union library(tidyr) library(ggplot2) ## Warning: package &#39;ggplot2&#39; was built under R version 4.4.3 library(stringr) library(lubridate) # uso explícito (parseo, wday, hour, etc.) ## ## Adjuntando el paquete: &#39;lubridate&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## date, intersect, setdiff, union library(zoo) # uso explícito (zoo, rollmean, lag) ## Warning: package &#39;zoo&#39; was built under R version 4.4.3 ## ## Adjuntando el paquete: &#39;zoo&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## as.Date, as.Date.numeric library(forecast) # ACF/PACF, ggseasonplot, ggsubseriesplot, autoplot.ts ## Warning: package &#39;forecast&#39; was built under R version 4.4.3 ## Registered S3 method overwritten by &#39;quantmod&#39;: ## method from ## as.zoo.data.frame zoo 1.1 Lectura del CSV csv_dir &lt;- &quot;C:/Users/Lenovo/PUJ Cali/OSCAR VELASQUEZ CHALA - Proyecto Aplicado - Proy. Demanda Electrica/2. Fuentes de Datos&quot; csv_name &lt;- &quot;015 SOLO POTENCIA PARA SUBI A BOOKDOWN.csv&quot; csv_path &lt;- file.path(csv_dir, csv_name) df &lt;- tryCatch( readr::read_csv(csv_path, show_col_types = FALSE), error = function(e) readr::read_csv2(csv_path, show_col_types = FALSE) ) glimpse(df) ## Rows: 118,647 ## Columns: 2 ## $ FECHA &lt;dttm&gt; 2018-01-15 00:00:00, 2018-01-15 01:00:00, 2018-01-15 0… ## $ VALOR_IMPUTADO &lt;dbl&gt; 0.6000, 0.5575, 0.5000, 0.5000, 0.5000, 0.5000, 0.4450,… time_col &lt;- &quot;FECHA&quot; y_col &lt;- &quot;VALOR_IMPUTADO&quot; Lectura y preparación df &lt;- tryCatch( readr::read_csv(csv_path, show_col_types = FALSE), error = function(e) readr::read_csv2(csv_path, show_col_types = FALSE) ) stopifnot(&quot;No existe la columna FECHA&quot; = time_col %in% names(df)) stopifnot(&quot;No existe la columna VALOR_IMPUTADO&quot; = y_col %in% names(df)) glimpse(df) ## Rows: 118,647 ## Columns: 2 ## $ FECHA &lt;dttm&gt; 2018-01-15 00:00:00, 2018-01-15 01:00:00, 2018-01-15 0… ## $ VALOR_IMPUTADO &lt;dbl&gt; 0.6000, 0.5575, 0.5000, 0.5000, 0.5000, 0.5000, 0.4450,… Parseo de fecha/hora con lubridate (zona: America/Bogota) dat &lt;- df %&gt;% transmute( .t_raw = .data[[time_col]], .t = suppressWarnings( lubridate::parse_date_time(.t_raw, orders = c(&quot;Ymd HMS&quot;,&quot;Ymd HM&quot;,&quot;Ymd&quot;, &quot;dmY HMS&quot;,&quot;dmY HM&quot;,&quot;dmY&quot;, &quot;dmy HMS&quot;,&quot;dmy HM&quot;,&quot;dmy&quot;, &quot;YmdT&quot;,&quot;YmdH&quot;,&quot;YmdHMS&quot;), tz = &quot;America/Bogota&quot;) ), y = as.numeric(.data[[y_col]]) ) %&gt;% mutate( # Si arriba quedó NA, intenta Date simple .t = ifelse(is.na(.t), as.POSIXct(as.Date(.t_raw), tz = &quot;America/Bogota&quot;), .t), .t = as.POSIXct(.t, tz = &quot;America/Bogota&quot;) ) %&gt;% filter(!is.na(.t), !is.na(y)) %&gt;% arrange(.t) stopifnot(&quot;No hay observaciones válidas&quot; = nrow(dat) &gt; 1) summary(dat$y); range(dat$.t) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0 1241 3550 3244 4996 10000 ## [1] &quot;2018-01-15 00:00:00 -05&quot; &quot;2025-09-01 07:00:00 -05&quot; Clase Date y granularidad dat &lt;- dat %&gt;% mutate(date = as.Date(.t)) # Diferencia mediana entre timestamps para inferir frecuencia dt_med &lt;- median(diff(dat$.t)) dt_med ## Time difference of 3600 secs infer_freq &lt;- function(dt) { secs &lt;- as.numeric(dt, units = &quot;secs&quot;) if (is.na(secs) || secs &lt;= 0) return(list(freq = 1, label = &quot;sin_frecuencia&quot;)) if (abs(secs - 60*60*24) &lt; 1) return(list(freq = 365, label = &quot;diaria&quot;)) if (abs(secs - 60*60) &lt; 1) return(list(freq = 24, label = &quot;horaria&quot;)) if (abs(secs - 60*30) &lt; 1) return(list(freq = 48, label = &quot;cada_30_min&quot;)) if (abs(secs - 60*15) &lt; 1) return(list(freq = 96, label = &quot;cada_15_min&quot;)) if (abs(secs - 60*5) &lt; 1) return(list(freq = 288, label = &quot;cada_5_min&quot;)) list(freq = 1, label = &quot;otra&quot;) } gran &lt;- infer_freq(dt_med) gran ## $freq ## [1] 24 ## ## $label ## [1] &quot;horaria&quot; Serie como zoo y como ts # Objeto zoo (requerido) z &lt;- zoo::zoo(dat$y, order.by = dat$.t) ## Warning in zoo::zoo(dat$y, order.by = dat$.t): some methods for &quot;zoo&quot; objects ## do not work if the index entries in &#39;order.by&#39; are not unique # Objeto ts (requerido) freq &lt;- gran$freq ts_label &lt;- gran$label # Heurística &quot;mensual&quot;: si hay múltiples observaciones por mes, agregamos a promedio mensual looks_monthly &lt;- { ym &lt;- zoo::as.yearmon(dat$.t) length(unique(ym)) &lt; nrow(dat) &amp;&amp; length(unique(ym)) &gt;= 6 } if (looks_monthly) { ym &lt;- zoo::as.yearmon(dat$.t) monthly &lt;- aggregate(dat$y, by = list(ym = ym), FUN = mean, na.rm = TRUE) %&gt;% arrange(ym) ts_y &lt;- ts(monthly$x, frequency = 12, start = c(year(as.Date(as.yearmon(monthly$ym[1]))), month(as.Date(as.yearmon(monthly$ym[1]))))) ts_label &lt;- &quot;mensual&quot; } else { ts_y &lt;- ts(dat$y, frequency = max(1, freq)) } list(class_zoo = class(z), class_ts = class(ts_y), freq_ts = frequency(ts_y), etiqueta = ts_label) ## $class_zoo ## [1] &quot;zoo&quot; ## ## $class_ts ## [1] &quot;ts&quot; ## ## $freq_ts ## [1] 12 ## ## $etiqueta ## [1] &quot;mensual&quot; Visualización base autoplot(ts_y) + labs(title = paste(&quot;Serie temporal (freq:&quot;, frequency(ts_y), &quot;-&quot;, ts_label, &quot;)&quot;), x = &quot;Tiempo&quot;, y = y_col) + theme_minimal() 6) Promedio móvil (Moving Average) Ventanas sugeridas según granularidad: 15-min: 96 (≈1 día) • Horaria: 24 (≈1 día) • Diaria: 7 (≈1 semana) • Mensual: 12 (≈1 año). k &lt;- dplyr::case_when( frequency(ts_y) &gt;= 288 ~ 288, frequency(ts_y) &gt;= 96 ~ 96, frequency(ts_y) &gt;= 24 ~ 24, frequency(ts_y) &gt;= 12 ~ 12, frequency(ts_y) &gt;= 7 ~ 7, TRUE ~ 5 ) ma &lt;- zoo::rollmean(z, k = k, align = &quot;right&quot;, fill = NA) ## Warning in zoo(rval[i], index(x)[i]): some methods for &quot;zoo&quot; objects do not ## work if the index entries in &#39;order.by&#39; are not unique ma_df &lt;- tibble( .t = index(z), y = coredata(z), ma = as.numeric(ma) ) ggplot(ma_df, aes(.t, y)) + geom_line(alpha = 0.7) + geom_line(aes(y = ma), linewidth = 1) + labs(title = paste0(&quot;Promedio móvil (k = &quot;, k, &quot;)&quot;), x = &quot;Tiempo&quot;, y = y_col) + theme_minimal() ## Warning: Removed 11 rows containing missing values or values outside the scale range ## (`geom_line()`). 7) Rezagos (lags) y autocorrelación h &lt;- min(48, max(12, frequency(ts_y))) # horizonte para ACF/PACF lk &lt;- min(24, h) # Crea los rezagos correctamente lz1 &lt;- dplyr::lag(coredata(z), 1) # y_{t-1} lzk &lt;- dplyr::lag(coredata(z), lk) # y_{t-lk} # Construye el tibble y elimina NA lag_df &lt;- tibble( y_t = coredata(z), y_l1 = lz1, y_lk = lzk ) %&gt;% drop_na() # Gráficos p1 &lt;- ggplot(lag_df, aes(y_l1, y_t)) + geom_point(alpha=.35) + labs(title = &quot;Lag plot: y[t] vs y[t-1]&quot;, x = expression(y[t-1]), y = expression(y[t])) + theme_minimal() p2 &lt;- ggplot(lag_df, aes(y_lk, y_t)) + geom_point(alpha=.35) + labs(title = paste0(&quot;Lag plot: y[t] vs y[t-&quot;, lk, &quot;]&quot;), x = bquote(y[t-.(lk)]), y = expression(y[t])) + theme_minimal() p1; p2 8) Estacionalidad Si frequency(ts_y) &gt; 1, aplicamos STL y plots estacionales. Si no, mostramos patrones por calendario con lubridate. if (frequency(ts_y) &gt; 1) { stl_fit &lt;- stl(ts_y, s.window = &quot;periodic&quot;, robust = TRUE) autoplot(stl_fit) + theme_minimal() } else { cat(&quot;No se detectó frecuencia &gt; 1 para STL.\\n&quot;) } ## Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0. ## ℹ Please use `linewidth` instead. ## ℹ The deprecated feature was likely used in the forecast package. ## Please report the issue at &lt;https://github.com/robjhyndman/forecast/issues&gt;. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was ## generated. if (frequency(ts_y) &gt; 1) { forecast::ggseasonplot(ts_y, year.labels = TRUE, year.labels.left = TRUE) + theme_minimal() + ggtitle(&quot;Gráfico estacional (ggseasonplot)&quot;) forecast::ggsubseriesplot(ts_y) + theme_minimal() + ggtitle(&quot;Subseries estacionales&quot;) } else { aux &lt;- dat %&gt;% mutate( dow = wday(.t, label = TRUE, week_start = 1), hod = hour(.t) ) ggplot(aux, aes(dow, y)) + geom_boxplot() + labs(title = &quot;Distribución por día de semana&quot;, x = &quot;Día de semana&quot;, y = y_col) + theme_minimal() if (dplyr::n_distinct(aux$hod) &gt; 1) { ggplot(aux, aes(hod, y)) + stat_summary(fun = mean, geom = &quot;line&quot;) + labs(title = &quot;Promedio por hora del día&quot;, x = &quot;Hora&quot;, y = y_col) + theme_minimal() } } ## Warning in fortify(data, ...): Arguments in `...` must be used. ## ✖ Problematic argument: ## • na.rm = TRUE ## ℹ Did you misspell an argument name? ## Arguments in `...` must be used. ## ✖ Problematic argument: ## • na.rm = TRUE ## ℹ Did you misspell an argument name? 9) Resumen y próximos pasos cat(&quot;**Frecuencia (ts):**&quot;, frequency(ts_y), &quot; | **Etiqueta:**&quot;, ts_label, &quot;\\n\\n&quot;) ## **Frecuencia (ts):** 12 | **Etiqueta:** mensual cat(&quot;- Se graficó la serie y su **promedio móvil** (k =&quot;, k, &quot;).\\n&quot;) ## - Se graficó la serie y su **promedio móvil** (k = 12 ). cat(&quot;- Se exploraron **rezagos** (lag-1 y lag-&quot;, lk, &quot;) y **ACF/PACF**.\\n&quot;, sep = &quot;&quot;) ## - Se exploraron **rezagos** (lag-1 y lag-12) y **ACF/PACF**. if (frequency(ts_y) &gt; 1) { cat(&quot;- **Estacionalidad**: STL + seasonplot/subseries.\\n&quot;) } else { cat(&quot;- Sin frecuencia estacional; se mostraron patrones por calendario (lubridate).\\n&quot;) } ## - **Estacionalidad**: STL + seasonplot/subseries. cat(&quot;\\n**Siguiente paso:** resamplear a granularidad fija, preparar *train/test* y validación temporal con orígenes rodantes.\\n&quot;) ## ## **Siguiente paso:** resamplear a granularidad fija, preparar *train/test* y validación temporal con orígenes rodantes. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
