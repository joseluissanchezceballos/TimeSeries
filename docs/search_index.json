[["index.html", "Propuesta de serie de tiempo: Predicción de demanda eléctrica a corto plazo Maestría en Ciencia de Datos 1 Presentación del Bookdown", " Propuesta de serie de tiempo: Predicción de demanda eléctrica a corto plazo Maestría en Ciencia de Datos Fredy A. Ordoñez · Oscar F. Velásquez · José L. Sánchez 20 de octubre de 2025 1 Presentación del Bookdown Este Bookdown recopila las actividades desarrolladas a lo largo del curso de Series de Tiempo. Cada capítulo corresponde a una entrega o avance del proyecto, permitiendo evidenciar el progreso del análisis, los modelos aplicados y las conclusiones del trabajo final. ## NULL "],["propuesta.html", "2 Propuesta de serie de tiempo: Predicción de demanda eléctrica a corto plazo 2.1 ¿Qué voy a pronosticar? 2.2 ¿Por qué es importante? 2.3 Fuente de datos y permisos 2.4 Impacto esperado 2.5 Referencias", " 2 Propuesta de serie de tiempo: Predicción de demanda eléctrica a corto plazo 2.1 ¿Qué voy a pronosticar? La demanda eléctrica de corto plazo (1 hora adelante) en una subestación de distribución, usando la serie de potencia activa (kW) con resolución horaria. 2.2 ¿Por qué es importante? Operación eficiente: anticipar picos para evitar sobrecargas y maniobras reactivas. Calidad del servicio (SAIDI/SAIFI): programar mantenimientos y gestionar eventos reduciendo frecuencia y duración de interrupciones.SAIFI (System Average Interruption Frequency Index) indica la frecuencia promedio de las interrupciones que un cliente experimenta en un período determinado (por ejemplo, cuántas veces se va la luz al año), y el SAIDI (System Average Interruption Duration Index) mide la duración promedio acumulada de esas interrupciones para un cliente en ese mismo período (cuánto tiempo en total está sin servicio). Valor agregado: entregar una plantilla reproducible (scripts, métricas y gráficos) que soporte decisiones operativas. 2.3 Fuente de datos y permisos Fuente: datos SCADA históricos del operador de red de una subestación específica resolución horaria. Permisos: uso académico con anonimización de subestación y operador; no se publican datos crudos, solo resultados agregados y visualizaciones. Alcance: una subestación; análisis offline (sin integración en tiempo real). 2.4 Impacto esperado Técnico: reducción de error frente a métodos manuales; soporte a decisiones en turnos. Económico: mejor dimensionamiento de respaldo y diferimiento de inversiones. Académico: caso replicable en otras subestaciones con datos equivalentes. 2.5 Referencias Hyndman, R. &amp; Athanasopoulos (2018). Forecasting: Principles and Practice (3ª). Box, G. et al. (2015). Time Series Analysis: Forecasting and Control (5ª). Zhang, H. et al. (2019). “Short-term Load Forecasting Using LSTM Networks”, IEEE TSG. Herramienta TIC: Bookdown + GitHub Pages Sitio: https://joseluissanchezceballos.github.io/TimeSeries/propuesta.html Repo: https://github.com/joseluissanchezceballos/TimeSeries "],["análisis-de-serie-de-tiempo-potencia-eléctrica-horaria.html", "3 Análisis de Serie de Tiempo: Potencia Eléctrica Horaria 3.1 Contexto y objetivos 3.2 Cargue de Librerías 3.3 Lectura y preparación de los datos 3.4 Funciones auxiliares de visualización de la serie de tiempo 3.5 Vista general del comportamiento de la potencia eléctrica por escalas (diaria, semanal, mensual, anual) 3.6 Curvas de potencia eléctrica por periodo (día, semana, mes, año) 3.7 Promedios móviles 3.8 Rezagos (lags) y autocorrelación 3.9 Estacionalidad (gráficos y descomposición) 3.10 Indicadores resumidos 3.11 Conclusiones", " 3 Análisis de Serie de Tiempo: Potencia Eléctrica Horaria 3.1 Contexto y objetivos El estudio analiza una serie temporal de potencia eléctrica horaria entre 2018 y 2025. El objetivo fue detectar patrones, ciclos y estacionalidades usando herramientas de R (lubridate, zoo, forecast) y visualizar la calidad de los datos (huecos, tendencias, estacionalidad, rezagos). El conjunto de datos es altamente completo: Completitud global: 99.48%. Años con menos completitud: 2019 (97.9%) y 2021 (99.4%). Años recientes (2022–2025): 100% de registros, sin huecos. La idea es detectar patrones y ciclos del comportamiento de la potencia eléctrica. 3.2 Cargue de Librerías library(readr) library(dplyr) ## ## Adjuntando el paquete: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union library(tidyr) library(lubridate) ## ## Adjuntando el paquete: &#39;lubridate&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## date, intersect, setdiff, union library(ggplot2) library(scales) ## ## Adjuntando el paquete: &#39;scales&#39; ## The following object is masked from &#39;package:readr&#39;: ## ## col_factor library(zoo) ## ## Adjuntando el paquete: &#39;zoo&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## as.Date, as.Date.numeric library(forecast) ## Registered S3 method overwritten by &#39;quantmod&#39;: ## method from ## as.zoo.data.frame zoo 3.3 Lectura y preparación de los datos csv_dir &lt;- &quot;C:/Users/Lenovo/PUJ Cali/OSCAR VELASQUEZ CHALA - Proyecto Aplicado - Proy. Demanda Electrica/2. Fuentes de Datos&quot; csv_name &lt;- &quot;015 SOLO POTENCIA PARA SUBI A BOOKDOWN.csv&quot; csv_path &lt;- file.path(csv_dir, csv_name) time_col &lt;- &quot;FECHA&quot; y_col &lt;- &quot;VALOR_IMPUTADO&quot; TZ &lt;- &quot;America/Bogota&quot; # Lectura robusta df &lt;- tryCatch( readr::read_csv(csv_path, show_col_types = FALSE), error = function(e) readr::read_csv2(csv_path, show_col_types = FALSE) ) stopifnot(time_col %in% names(df), y_col %in% names(df)) # Parseo de fechas (varios formatos) df[[time_col]] &lt;- parse_date_time( df[[time_col]], orders = c(&quot;ymd HMS&quot;,&quot;ymd HM&quot;,&quot;dmy HMS&quot;,&quot;dmy HM&quot;,&quot;ymd&quot;,&quot;dmy&quot;), tz = TZ ) # A numérico df[[y_col]] &lt;- suppressWarnings(readr::parse_number(as.character(df[[y_col]]))) # Malla horaria completa (sin imputar, para marcar huecos) df0 &lt;- df %&gt;% filter(!is.na(.data[[time_col]])) %&gt;% select(!!time_col, !!y_col) %&gt;% arrange(.data[[time_col]]) full_time &lt;- tibble(!!time_col := seq(min(df0[[time_col]]), max(df0[[time_col]]), by = &quot;1 hour&quot;)) df_full &lt;- full_time %&gt;% left_join(df0, by = time_col) %&gt;% mutate(is_na = is.na(.data[[y_col]])) %&gt;% arrange(.data[[time_col]]) summary(df_full[[y_col]]) ## Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s ## 0 1241 3550 3244 4996 10000 610 cat(&quot;Proporción de NA:&quot;, mean(is.na(df_full[[y_col]])), &quot;\\n&quot;) ## Proporción de NA: 0.005141302 3.4 Funciones auxiliares de visualización de la serie de tiempo # Unir horas NA contiguas en bandas na_spans_runs &lt;- function(x_time, is_na_logical) { r &lt;- rle(is_na_logical) ed &lt;- cumsum(r$lengths); st &lt;- ed - r$lengths + 1 tibble(is_na = r$values, i_start = st, i_end = ed) %&gt;% dplyr::filter(is_na) %&gt;% transmute(xmin = x_time[i_start], xmax = x_time[i_end] + hours(1)) } # Agregación genérica sin imputar tagrega &lt;- function(data, unit, time_col, y_col, tz = TZ) { data %&gt;% mutate(period = floor_date(.data[[time_col]], unit)) %&gt;% group_by(period) %&gt;% summarise(value = mean(.data[[y_col]], na.rm = TRUE), .groups = &quot;drop&quot;) } 3.5 Vista general del comportamiento de la potencia eléctrica por escalas (diaria, semanal, mensual, anual) na_runs &lt;- na_spans_runs(df_full[[time_col]], df_full$is_na) plot_df &lt;- bind_rows( tagrega(df_full, &quot;day&quot;, time_col, y_col) %&gt;% mutate(freq = &quot;Diaria&quot;), tagrega(df_full, &quot;week&quot;, time_col, y_col) %&gt;% mutate(freq = &quot;Semanal&quot;), tagrega(df_full, &quot;month&quot;, time_col, y_col) %&gt;% mutate(freq = &quot;Mensual&quot;), tagrega(df_full, &quot;year&quot;, time_col, y_col) %&gt;% mutate(freq = &quot;Anual&quot;) ) %&gt;% mutate(freq = factor(freq, levels = c(&quot;Diaria&quot;,&quot;Semanal&quot;,&quot;Mensual&quot;,&quot;Anual&quot;))) ggplot() + geom_rect(data = na_runs, aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf), inherit.aes = FALSE, fill = &quot;red&quot;, alpha = 0.25) + geom_line(data = plot_df, aes(x = period, y = value), linewidth = 0.7, na.rm = TRUE) + facet_wrap(~ freq, scales = &quot;free_x&quot;, ncol = 2) + scale_x_datetime(labels = date_format(&quot;%Y&quot;), date_breaks = &quot;1 year&quot;) + labs(title = &quot;Potencia con huecos (NA)&quot;, subtitle = &quot;Bandas rojas = periodos con NA en la serie horaria original&quot;, x = &quot;Tiempo&quot;, y = &quot;Potencia&quot;) + theme_minimal(base_size = 11) Curva de Potencia Diaria: muestra alta variabilidad horaria con picos bien definidos, evidenciando que la potencia cambia fuertemente a lo largo del día. Curva de Potencia Semanal: suaviza los ciclos, pero aún se aprecian repeticiones cada pocos días, sugiriendo un patrón operativo estable. Curva de Potencia Mensual: las oscilaciones se atenúan, revelando la tendencia global; los huecos rojos (NA) se observan concentrados en pocos periodos. Curva de Potencia Anual: la línea muestra el comportamiento global a largo rango: valores medios estables sin deriva significativa, lo que sugiere una operación controlada y sin aumento sostenido del consumo. La serie mantiene un patrón estacional fuerte (diario y semanal) y una tendencia global estacionaria. Los huecos (en rojo) son mínimos y no distorsionan las medias agregadas. 3.6 Curvas de potencia eléctrica por periodo (día, semana, mes, año) # Día dia_obj &lt;- as.Date(&quot;2023-02-01&quot;) ini_dia &lt;- as.POSIXct(dia_obj, tz = TZ); fin_dia &lt;- ini_dia + days(1) df_day &lt;- df_full %&gt;% filter(.data[[time_col]] &gt;= ini_dia, .data[[time_col]] &lt; fin_dia) na_day &lt;- na_spans_runs(df_day[[time_col]], df_day$is_na) g_day &lt;- ggplot() + geom_rect(data = na_day, aes(xmin = xmin, xmax = xmax, ymin=-Inf, ymax=Inf), inherit.aes = FALSE, fill=&quot;red&quot;, alpha = 0.35) + geom_line(data = filter(df_day, !is_na), aes_string(x=time_col, y=y_col), linewidth=0.8) + scale_x_datetime(limits=c(ini_dia, fin_dia), date_labels=&quot;%H:%M&quot;, breaks=seq(ini_dia, fin_dia, by=&quot;2 hour&quot;)) + labs(title=paste0(&quot;Curva horaria — &quot;, dia_obj), x=&quot;Hora&quot;, y=&quot;Potencia&quot;) + theme_minimal() g_day Día: 1 febrero 2023:Curva con forma sinusoidal: potencia baja en la madrugada, aumento progresivo durante el día, pico en horas centrales y descenso nocturno. Refleja un ciclo operativo típico diario. # Semana semana_ref &lt;- as.Date(&quot;2021-02-01&quot;) ini_sem &lt;- as.POSIXct(floor_date(semana_ref, &quot;week&quot;, week_start=1), tz=TZ) fin_sem &lt;- ini_sem + weeks(1) df_week &lt;- df_full %&gt;% filter(.data[[time_col]] &gt;= ini_sem, .data[[time_col]] &lt; fin_sem) na_week &lt;- na_spans_runs(df_week[[time_col]], df_week$is_na) g_week &lt;- ggplot() + geom_rect(data = na_week, aes(xmin = xmin, xmax = xmax, ymin=-Inf, ymax=Inf), inherit.aes = FALSE, fill=&quot;red&quot;, alpha = 0.35) + geom_line(data = filter(df_week, !is_na), aes_string(x=time_col, y=y_col), linewidth=0.8) + scale_x_datetime(limits=c(ini_sem, fin_sem), date_labels=&quot;%a %d&quot;, breaks=seq(ini_sem, fin_sem, by=&quot;1 day&quot;)) + labs(title=paste0(&quot;Semana del &quot;, ini_sem), x=&quot;Fecha&quot;, y=&quot;Potencia&quot;) + theme_minimal() g_week Semana: 1–7 febrero 2021: Repetición diaria clara, pero con leves diferencias entre días. Puede reflejar cambios de carga entre jornadas laborales y fines de semana. # Mes mes_ref &lt;- as.Date(&quot;2021-02-01&quot;) ini_mes &lt;- as.POSIXct(floor_date(mes_ref, &quot;month&quot;), tz=TZ); fin_mes &lt;- as.POSIXct(ceiling_date(mes_ref, &quot;month&quot;), tz=TZ) df_month &lt;- df_full %&gt;% filter(.data[[time_col]] &gt;= ini_mes, .data[[time_col]] &lt; fin_mes) na_month &lt;- na_spans_runs(df_month[[time_col]], df_month$is_na) g_month &lt;- ggplot() + geom_rect(data = na_month, aes(xmin = xmin, xmax = xmax, ymin=-Inf, ymax=Inf), inherit.aes = FALSE, fill=&quot;red&quot;, alpha = 0.25) + geom_line(data = filter(df_month, !is_na), aes_string(x=time_col, y=y_col), linewidth=0.6) + scale_x_datetime(limits=c(ini_mes, fin_mes), date_labels=&quot;%d-%b&quot;, breaks=seq(ini_mes, fin_mes, by=&quot;3 days&quot;)) + labs(title=paste0(&quot;Mes &quot;, format(ini_mes, &#39;%Y-%m&#39;)), x=&quot;Fecha&quot;, y=&quot;Potencia&quot;) + theme_minimal() g_month Mes: febrero 2021: Patrón reiterado de picos semanales. Los huecos rojos (NA) marcan interrupciones puntuales sin afectar la tendencia global. # Año (panel único) anio_ref &lt;- 2021 ini_anio &lt;- as.POSIXct(ymd(paste0(anio_ref, &quot;-01-01&quot;)), tz=TZ); fin_anio &lt;- as.POSIXct(ymd(paste0(anio_ref+1, &quot;-01-01&quot;)), tz=TZ) df_year &lt;- df_full %&gt;% filter(.data[[time_col]] &gt;= ini_anio, .data[[time_col]] &lt; fin_anio) na_year &lt;- na_spans_runs(df_year[[time_col]], df_year$is_na) g_year &lt;- ggplot() + geom_rect(data = na_year, aes(xmin = xmin, xmax = xmax, ymin=-Inf, ymax=Inf), inherit.aes = FALSE, fill=&quot;red&quot;, alpha = 0.20) + geom_line(data = filter(df_year, !is_na), aes_string(x=time_col, y=y_col), linewidth=0.3) + scale_x_datetime(limits=c(ini_anio, fin_anio), date_labels=&quot;%b&quot;, breaks=seq(ini_anio, fin_anio, by=&quot;1 month&quot;)) + labs(title=paste0(&quot;Año &quot;, anio_ref), x=&quot;Mes&quot;, y=&quot;Potencia&quot;) + theme_minimal() g_year Año: 2021: Oscilaciones estacionales sin tendencia definida. No se observan desviaciones estructurales. A nivel temporal, la potencia responde a ciclos regulares con comportamiento casi periódico. 3.7 Promedios móviles Promedios móviles sobre la serie horaria (imputada solo para continuidad visual con na.interp). # --- Promedios móviles coloreados (24h, 168h, 720h) --- # 1) Crea la serie imputada y los MAs df_impu &lt;- df_full %&gt;% mutate(val_impu = forecast::na.interp(.data[[y_col]])) df_ma &lt;- df_impu %&gt;% transmute( time = .data[[time_col]], y = as.numeric(val_impu), `MA 24h` = zoo::rollmean(val_impu, k = 24, align = &quot;right&quot;, fill = NA), `MA 168h` = zoo::rollmean(val_impu, k = 168, align = &quot;right&quot;, fill = NA), `MA 720h` = zoo::rollmean(val_impu, k = 720, align = &quot;right&quot;, fill = NA) ) # 2) Pasar los MAs a formato largo para mapear color por serie library(tidyr) df_ma_long &lt;- df_ma %&gt;% tidyr::pivot_longer(cols = c(`MA 24h`,`MA 168h`,`MA 720h`), names_to = &quot;Serie&quot;, values_to = &quot;Valor&quot;) # 3) Graficar: original en gris, MAs en colores ggplot(df_ma, aes(x = time)) + # Serie original geom_line(aes(y = y), color = &quot;grey80&quot;, linewidth = 0.2, alpha = 0.6) + # Promedio móvil corto (24h) — se dibuja primero geom_line(aes(y = `MA 24h`), color = &quot;#1f77b4&quot;, linewidth = 0.6, alpha = 0.8) + # Promedio móvil intermedio (168h) — encima de la azul geom_line(aes(y = `MA 168h`), color = &quot;#2ca02c&quot;, linewidth = 0.9, alpha = 0.9) + # Promedio móvil largo (720h) — encima de las anteriores geom_line(aes(y = `MA 720h`), color = &quot;#d62728&quot;, linewidth = 1.1, alpha = 1) + labs( title = &quot;Promedios móviles (24h, 168h, 720h)&quot;, subtitle = &quot;Curvas suavizadas de corto, mediano y largo plazo&quot;, x = &quot;Tiempo&quot;, y = &quot;Potencia&quot; ) + theme_minimal(base_size = 12) + theme(plot.title = element_text(face = &quot;bold&quot;)) La línea gris (serie original) muestra picos horarios abruptos. La línea azul (media móvil 24h) suaviza el ruido diario. La línea verde (media móvil 168h) identifica la tendencia semanal. La línea roja (media móvil 720h) resume la tendencia mensual. No se observan rupturas ni tendencias marcadas. Las tres medias convergen en un rango estable. 3.8 Rezagos (lags) y autocorrelación # --- Rezagos a nivel horario (1, 24, 168, 720) --- df_lags &lt;- df_impu %&gt;% transmute( time = .data[[time_col]], y = as.numeric(val_impu), lag_1 = dplyr::lag(as.numeric(val_impu), 1), lag_24 = dplyr::lag(as.numeric(val_impu), 24), lag_168 = dplyr::lag(as.numeric(val_impu), 168), lag_720 = dplyr::lag(as.numeric(val_impu), 720) ) # Correlaciones cors &lt;- c( cor(df_lags$y, df_lags$lag_1, use = &quot;complete.obs&quot;), cor(df_lags$y, df_lags$lag_24, use = &quot;complete.obs&quot;), cor(df_lags$y, df_lags$lag_168, use = &quot;complete.obs&quot;), cor(df_lags$y, df_lags$lag_720, use = &quot;complete.obs&quot;) ) setNames(round(cors, 3), c(&quot;lag1&quot;,&quot;lag24&quot;,&quot;lag168&quot;,&quot;lag720&quot;)) ## lag1 lag24 lag168 lag720 ## 0.977 0.802 0.766 0.749 Lag 1: 0.977 → fuerte dependencia entre horas consecutivas. Lag 24: 0.802 → patrón diario repetitivo. Lag 168: 0.766 → correlación semanal clara. Lag 720: 0.749 → correlación mensual aún significativa. Los altos valores confirman una autocorrelación fuerte y múltiple (hora, día, semana, mes). Esto valida la presencia de estacionalidad múltiple y un comportamiento cíclico persistente. #ACF y PACF: Análisis de Autocorrelación library(ggplot2) # 1) Serie imputada -&gt; vector numérico sin NA serie_vec &lt;- as.numeric(df_impu$val_impu) serie_vec &lt;- serie_vec[!is.na(serie_vec)] # 2) Definir lag máximo (p.ej. 30 días = 24*30) max_lag &lt;- 24 * 30 # 3) Calcular ACF y PACF sin graficar acf_obj &lt;- acf(serie_vec, lag.max = max_lag, plot = FALSE) pacf_obj &lt;- pacf(serie_vec, lag.max = max_lag, plot = FALSE) # 4) Pasar a data frame (ojo: ambos traen valores en $acf) acf_df &lt;- data.frame( lag = as.numeric(acf_obj$lag), acf = as.numeric(acf_obj$acf) ) pacf_df &lt;- data.frame( lag = as.numeric(pacf_obj$lag), # lags desde 1 normalmente pacf = as.numeric(pacf_obj$acf) # valores de PACF están en $acf ) # 5) Bandas de confianza 95% n_eff &lt;- length(serie_vec) ci &lt;- 1.96 / sqrt(n_eff) # 6) Graficar con ggplot2 # --- ACF --- ggplot(acf_df, aes(x = lag, y = acf)) + geom_col(width = 0.9) + geom_hline(yintercept = 0, linewidth = 0.3) + geom_hline(yintercept = c(-ci, ci), linetype = &quot;dashed&quot;, color = &quot;red&quot;) + labs(title = &quot;ACF - Autocorrelación de la serie horaria&quot;, subtitle = paste(&quot;Límites 95% ±&quot;, round(ci, 3)), x = &quot;Rezago (horas)&quot;, y = &quot;ACF&quot;) + theme_minimal(base_size = 12) El gráfico ACF muestra la correlación de la serie de potencia horaria consigo misma a diferentes rezagos (lags), medidos en horas. En el rezago 0 la autocorrelación es 1, cada punto está completamente correlacionado consigo mismo. Se observa una autocorrelación muy alta y sostenida en casi todos los rezagos, con valores cercanos a 0.75–0.80 hasta aproximadamente 700 horas (~30 días). Esta persistencia indica que la serie mantiene una dependencia temporal fuerte, es decir, los valores pasados tienen gran influencia sobre los futuros. Se aprecian picos regulares (aprox. cada 24, 168 y 720 rezagos), lo que evidencia patrones estacionales diarios, semanales y mensuales. Las bandas rojas horizontales representan los límites de significancia al 95% (±0.006). Todos los valores de la ACF están muy por encima de esas bandas, lo que confirma que la autocorrelación es estadísticamente significativa en todos los horizontes analizados. La serie presenta una estructura fuertemente autocorrelacionada, con periodicidad marcada y ciclos regulares. Esto indica que no es una serie puramente aleatoria, sino que está dominada por una estacionalidad sistemática de carácter diario y semanal. # --- PACF --- ggplot(pacf_df, aes(x = lag, y = pacf)) + geom_col(width = 0.9) + geom_hline(yintercept = 0, linewidth = 0.3) + geom_hline(yintercept = c(-ci, ci), linetype = &quot;dashed&quot;, color = &quot;red&quot;) + labs(title = &quot;PACF - Autocorrelación parcial&quot;, subtitle = paste(&quot;Límites 95% ±&quot;, round(ci, 3)), x = &quot;Rezago (horas)&quot;, y = &quot;PACF&quot;) + theme_minimal(base_size = 12) El gráfico PACF muestra la correlación entre la serie y sus rezagos una vez eliminada la influencia de los rezagos intermedios. Se observa un pico alto en el primer rezago (lag = 1), lo que indica una fuerte dependencia inmediata (efecto de la hora anterior). Después del primer rezago, los valores de la PACF caen rápidamente y se mantienen cerca de cero, salvo algunos picos débiles en rezagos aproximadamente iguales a 24, 168 y 720 horas, que corresponden a efectos estacionales. Estos picos secundarios son pequeños pero significativos, lo que sugiere una estacionalidad múltiple (día, semana, mes). La PACF confirma que el comportamiento actual de la potencia depende principalmente de su valor en la hora anterior (AR(1)), junto con componentes estacionales de largo plazo. 3.9 Estacionalidad (gráficos y descomposición) Para descomponer, usamos un objeto ts regular con frecuencia diaria (24), semanal (24*7) o anual (24*365). Utilizamos la serie imputada val_impu para evitar huecos. # Construir ts con frecuencia diaria (24 por ciclo) start_time &lt;- min(df_impu[[time_col]], na.rm = TRUE) Indice.ts.diaria &lt;- ts(df_impu$val_impu, start = c(year(start_time), hour(start_time) + 1), frequency = 24) # Gráficos estacionales (por hora del día y por mes) autoplot(Indice.ts.diaria) + ggtitle(&quot;Serie ts (freq=24)&quot;) Serie ts (freq = 24) La serie presenta alta variabilidad (cada día cambia mucho), con rupturas o cambios estructurales en determinados años. Esto indica que el sistema de potencia tiene patrones por periodos largos más que una estacionalidad estricta diaria. # STL y gráficos estacionales fit_stl &lt;- stl(Indice.ts.diaria, s.window = &quot;periodic&quot;) plot(fit_stl, main = &quot;Descomposición STL (frecuencia diaria)&quot;) Decomposición STL frecuencia diaria * data: Muestra la potencia total observada con todas sus fluctuaciones. * seasonal: Se observa una banda negra uniforme, porque la variabilidad de la serie es mucho mayor que la amplitud de la estacionalidad. * trend: Se observan periodos con incrementos o descensos sostenidos de potencia * remainder: Presenta la variabilidad de corto plazo, los picos, fallos de medición y valores atípicos # Define un inicio dinámico (o fija una fecha) ini_zoom &lt;- as.POSIXct(&quot;2021-02-01&quot;, tz = TZ) fin_zoom &lt;- ini_zoom + lubridate::weeks(4) slice &lt;- df_impu %&gt;% dplyr::filter(.data[[time_col]] &gt;= ini_zoom, .data[[time_col]] &lt; fin_zoom) ts24_zoom &lt;- ts(as.numeric(slice$val_impu), frequency = 24) fit_zoom &lt;- stl(ts24_zoom, s.window = &quot;periodic&quot;, robust = TRUE) plot(fit_zoom, range.bars = FALSE, main = &quot;STL en ventana (4 semanas)&quot;) Decomposición STL en una ventana de 4 semanas data: Se observan oscilaciones regulares de subida y bajada cada 24 horas, lo cual refleja el patrón de potencia diario. Hay algunos huecos o caídas abruptas que corresponden a datos faltantes o interrupciones de registro de los datos. La serie se mueve alrededor de una media aproximada de 5000–6000 KW, con variaciones diarias de alrededor de ±1000 – 1500 KW. seasonal: Se observa una forma de onda repetitiva tipo sinusoinal, con un ciclo por día. La serie tiene una estacionalidad clara diaria: la potencia sube en ciertas horas (probablemente durante el día laboral) y baja en otras (probablemente por la noche). La amplitud del patrón se mantiene bastante constante, lo que sugiere que la estacionalidad diaria no cambia mucho entre semanas. trend: Se observan ondas de mayor periodo que podrían corresponder a variaciones semanales. La tendencia muestra subidas y bajadas lentas, lo que indica variabilidad estructural o cambios progresivos en el nivel medio de potencia. La escala vertical está alrededor de los 5000–7000 KW. remainder: Los picos hacia arriba o abajo representan anomalías, errores o eventos inusuales. Se observan algunos picos negativos fuertes, que podrían deberse a interrupciones o registros incorrectos de potencia (NA o 0). El resto del residuo oscila cerca de cero, lo cual es deseable (significa que la mayor parte de la variabilidad fue capturada por tendencia + estacionalidad). En resumen, la serie de potencia tiene una estacionalidad diaria fuerte, una tendencia suave semanal, y ruido moderado. 3.10 Indicadores resumidos # Completitud global comp_global &lt;- 1 - mean(is.na(df_full[[y_col]])) # Completitud por año comp_anio &lt;- df_full %&gt;% dplyr::group_by(anio = lubridate::year(.data[[time_col]])) %&gt;% dplyr::summarise( comp = 1 - mean(is.na(.data[[y_col]])), n_obs = dplyr::n(), .groups = &quot;drop&quot; ) comp_global ## [1] 0.9948587 comp_anio ## # A tibble: 8 × 3 ## anio comp n_obs ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2018 0.996 38330 ## 2 2019 0.979 15639 ## 3 2020 0.997 17424 ## 4 2021 0.994 11444 ## 5 2022 1 9793 ## 6 2023 1 9893 ## 7 2024 1 9712 ## 8 2025 1 6412 Año Completitud Observaciones 2018 99.6% Muy buena cobertura 2019 97.9% Ligera pérdida de datos 2020 99.7% Excelente 2021 99.4% Alta 2022–2025 100% Sin huecos 3.11 Conclusiones La serie de potencia es altamente estacionaria y cíclica. Existen ciclos claros de 24 y 168 horas, reflejando comportamientos diarios y semanales. No se detectan tendencias de crecimiento, lo que indica estabilidad en la operación. Los promedios móviles confirman consistencia estructural. La descomposición STL y la ACF refuerzan la idea de una estacionalidad regular y predecible. La calidad del registro (99.5%) garantiza confiabilidad para análisis predictivos. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
